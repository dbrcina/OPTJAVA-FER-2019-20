package hr.fer.zemris.optjava.dz6;

import java.util.*;
import java.util.function.BiFunction;

import static java.lang.Math.*;

public class MMAS {

    /*
    <!--------------Algorithm parameters--------------!>
     */
    private final double[][] points2D;
    private final int numberOfCandidates;
    private final int maxAnts;
    private final int maxIterations;
    private final double a;
    private final double rho;
    private final double delta = 1E-9;

    /*
    <!--------------Parameters generated by algorithm--------------!>
     */
    private int[][] candidates;
    private double[][] distances;
    private double[][] etaMatrix;
    private double[][] pheromones;
    private double bestValueSoFar = Double.MAX_VALUE;
    private double tauMin;
    private double tauMax;
    private double stagnationNumber;

    /*
    <!--------------Some helpful tools--------------!>
     */
    private final Random rand = new Random();
    private final BiFunction<Integer, Integer, Double> production;
    private final BiFunction<Integer, Integer, Double> calculateDistance;

    // constructor user for initialization
    public MMAS(
            double[][] points2D,
            int numberOfCandidates,
            int maxAnts,
            int maxIterations,
            double alpha,
            double beta,
            double a,
            double rho) {
        this.points2D = points2D;
        this.numberOfCandidates = numberOfCandidates;
        this.maxAnts = maxAnts;
        this.maxIterations = maxIterations;
        this.a = a;
        this.rho = rho;
        this.stagnationNumber = maxIterations / 2;
        this.production = (i, j) -> pow(pheromones[i][j], alpha) * pow(etaMatrix[i][j], beta);
        this.calculateDistance = (i, j) -> sqrt(pow(points2D[i][0] - points2D[j][0], 2)
                + pow(points2D[i][1] - points2D[j][1], 2));
    }

    public void run() {
        int size = points2D.length;
        initialize(size);

        int stagnationCounter = 0;
        for (int i = 0; i < maxIterations; i++) {
            int[][] antsSolutions = new int[maxAnts][size];
            double[] antValues = new double[maxAnts];
            double bestIthValue = Double.MAX_VALUE;
            for (int ant = 0; ant < maxAnts; ant++) {
                int[] solution = generateSolution(ant, size);
                double value = validateSolution(solution, size);
                antsSolutions[ant] = solution;
                antValues[ant] = value;
                bestIthValue = min(bestIthValue, value);
            }
            if (abs(bestValueSoFar - bestIthValue) < delta) stagnationCounter++;
            if (stagnationCounter == stagnationNumber) {
                resetPheromones(size);
                stagnationCounter = 0;
                continue;
            }
            if (bestIthValue < bestValueSoFar) {
                bestValueSoFar = bestIthValue;
                tauMax = 1 / (rho * bestValueSoFar);
                tauMin = calculateTauMin();
            }
            System.out.println((i + 1) + ". iteracija: " + bestValueSoFar);
            evaporatePheromones(size);
            updatePheromones(size, antsSolutions, antValues);
        }
    }

    private int[] generateSolution(int city, int size) {
        int[] solution = new int[size];
        solution[0] = city;
        boolean[] citiesVisited = new boolean[size];
        for (int i = 1; i < size; i++) {
            citiesVisited[city] = true;
            int[] remaining = new int[size];
            int candidatesAdded = 0;
            double[][] percentages;
            int[] citiesCandidates = candidates[city];
            for (int candidate : citiesCandidates) {
                if (!citiesVisited[candidate]) {
                    remaining[candidatesAdded++] = candidate;
                }
            }
            if (candidatesAdded != 0) {
                remaining = rearangeArray(remaining, candidatesAdded);
            } else {
                int othersAdded = 0;
                for (int j = 0; j < size; j++) {
                    if (!citiesVisited[j]) {
                        remaining[othersAdded++] = j;
                    }
                }
                remaining = rearangeArray(remaining, othersAdded);
            }
            percentages = percentages(citiesVisited, city, remaining);
            city = rouletteWheelSelection(percentages);
            solution[i] = city;
        }
        return solution;
    }

    private int[] rearangeArray(int[] array, int actualSize) {
        return Arrays.copyOf(array, actualSize);
    }

    private double[][] percentages(
            boolean[] citiesVisited,
            int city,
            int[] remaining) {
        double[][] candidatesPercentages = new double[remaining.length][2];
        for (int j = 0; j < remaining.length; j++) {
            int candidate = remaining[j];
            if (citiesVisited[candidate]) continue;
            double percentage = probabilityFunction(
                    city,
                    candidate,
                    remaining);
            candidatesPercentages[j][0] = percentage;
            candidatesPercentages[j][1] = candidate;
        }
        return candidatesPercentages;
    }

    private int rouletteWheelSelection(double[][] candidatesPercentages) {
        int city = 0;
        double[][] sortedCandidatesPercentages = Arrays.stream(candidatesPercentages)
                .filter(array -> Arrays.stream(array).noneMatch(d -> d == 0))
                .sorted(Comparator.comparingDouble(array -> array[0]))
                .toArray(double[][]::new);
        for (int j = 0; j < sortedCandidatesPercentages.length; j++) {
            double previous = 0;
            if (j != 0) previous = sortedCandidatesPercentages[j - 1][0];
            sortedCandidatesPercentages[j][0] += previous;
        }
        if (sortedCandidatesPercentages.length < numberOfCandidates && sortedCandidatesPercentages.length > 0) {
            sortedCandidatesPercentages[sortedCandidatesPercentages.length - 1][0] = 1;
        }
        double random = rand.nextDouble();
        for (double[] candidatePercentage : sortedCandidatesPercentages) {
            if (random < candidatePercentage[0]) {
                city = (int) candidatePercentage[1];
                break;
            }
        }
        return city;
    }

    private double probabilityFunction(int city, int candidate, int[] cityCandidates) {
        double sum = 0;
        for (int cityCandidate : cityCandidates) {
            sum += production.apply(city, cityCandidate);
        }
        return production.apply(city, candidate) / sum;
    }

    private void resetPheromones(int size) {
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                pheromones[i][j] = tauMax;
            }
        }
    }

    private void evaporatePheromones(int size) {
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                double value = pheromones[i][j] * (1 - rho);
                if (value < tauMin) {
                    value = tauMin;
                }
                pheromones[i][j] = value;
            }
        }
    }

    private void updatePheromones(int size, int[][] antsSolutions, double[] antValues) {
        for (int ant = 0; ant < size; ant++) {
            int[] antSolution = antsSolutions[ant];
            for (int i = 1; i < antSolution.length; i++) {
                int city1 = antSolution[i - 1];
                int city2 = antSolution[i];
                double value = pheromones[city1][city2] + 1 / antValues[ant];
                if (value > tauMax) {
                    value = tauMax;
                }
                pheromones[city1][city2] = value;
            }
        }
    }

    private double validateSolution(int[] solution, int size) {
        double distance = 0;
        for (int i = 1; i < size; i++) {
            int city1 = solution[i - 1];
            int city2 = solution[i];
            distance += distances[city1][city2];
        }
        int start = solution[0];
        int finish = solution[size - 1];
        return distance + distances[start][finish];
    }

    /*
    <!--------------Initialization block--------------!>
     */
    private void initialize(int size) {
        initializeDistancesAndEtas(size);
        initializeCandidates(size);
        initializePheromones(size);
    }

    private void initializeDistancesAndEtas(int size) {
        distances = new double[size][size];
        etaMatrix = new double[size][size];
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                double distance = calculateDistance.apply(i, j);
                distances[i][j] = distance;
                double division = 1 / distance;
                etaMatrix[i][j] = division == Double.POSITIVE_INFINITY ? 0 : division;
            }
        }
    }

    private void initializeCandidates(int size) {
        candidates = new int[size][numberOfCandidates];
        for (int i = 0; i < size; i++) {
            int index = 0;
            double[] distancesFromIthCity = distances[i];
            // sorted candidates by distance
            // element at first index is always 0,
            // so we limit stream to numberOfCandidates + 1
            // and skip that first element
            double[] sortedCandidates = Arrays.stream(distancesFromIthCity)
                    .sorted()
                    .limit(numberOfCandidates + 1)
                    .toArray();
            for (double candidate : sortedCandidates) {
                if (candidate == 0) continue;
                for (int j = 0; j < size; j++) {
                    if (distancesFromIthCity[j] == candidate) {
                        candidates[i][index++] = j;
                        break;
                    }
                }
            }
        }
    }

    private void initializePheromones(int size) {
        pheromones = new double[size][size];
        double smallestDistance = smallestDistanceGreedyAlg(size);
        // tau0
        tauMax = 1 / smallestDistance;
        tauMin = calculateTauMin();
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (i == j) continue;
                pheromones[i][j] = tauMax;
            }
        }
    }

    private double smallestDistanceGreedyAlg(int size) {
        boolean[] citiesVisited = new boolean[size];
        double smallestDistance = 0;
        int city = rand.nextInt(size);
        for (int i = 0; i < size; i++) {
            citiesVisited[city] = true;
            double[] cityDistances = distances[city];
            double min = Double.MAX_VALUE;
            int nextCity = 0;
            for (int j = 0; j < size; j++) {
                if (citiesVisited[j]) continue;
                double distance = cityDistances[j];
                if (distance < min) {
                    min = distance;
                    nextCity = j;
                }
            }
            if (min != Double.MAX_VALUE) {
                smallestDistance += min;
            }
            city = nextCity;
        }
        return smallestDistance;
    }

    private double calculateTauMin() {
        return tauMax / a;
    }

}
